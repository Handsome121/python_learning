"""
容器（container）
"""
# 容器是一种把多个元素组织在一起的数据结构，容器中的元素可以逐个地迭代获取，可以用in, not in关键字判断元素是否包含在容器中。

# 通常这类数据结构把所有的元素存储在内存中（并不是所有的元素都放在内存中，比如迭代器和生成器对象）

# 尽管绝大多数容器提供了某种方式来获取其中的每一个元素，但这并不是容器本身，而是可迭代对象赋予了容器这种能力，当然并不是所有的容器都是可迭代的

# 从技术角度讲当它可以用来询问某个元素是否包含在其中时，那么这个对象就可以认为时一个容器
"""
可迭代对象(iterable)
"""
# 刚才说过，很多容器都是可迭代对象，此外还有更多的对象同样也是可迭代对象，但凡可以返回一个迭代器的对象都可称之为可迭代对象
x = [1, 2, 3]
y = x.__iter__()  # y=iter(x)
z = x.__iter__()  # z=iter(x)
print(next(y))
print(next(y))
print(type(x))
print(type(y))
# 这里X时一个可迭代对象，可迭代对象和容器一样时一种通俗的叫法，并不是指某种具体的数据类型，List是可迭代对象，dict是可迭代对象，y和z是两个独立的迭代器

# 迭代器内部持有一个状态，该状态记录当前迭代所在的位置，以方便下次迭代的时候获取正确的元素，迭代器有一种具体的迭代器类型，比如list_iterator,set_iterator
# 可迭代对象实现了__iter__方法，该方法返回一个迭代器对象
"""
迭代器对象（iterator）
"""


# 迭代器，它是一个带状态的对象，他能在你调用next()方法的时候返回容器中的下一个值，任何实现了__iter__和__next__方法的对象都是迭代器对象，__iter__返回迭代器自身
# __next__返回容器中的下一个值，如果容器中没有更多元素了，则抛出StopIteration
# 所以迭代器实现了工厂模式的对象，它在你每次询问要下一个值的时候给你返回
class Fib:
    def __init__(self, n=10):  # 初始化
        self.prev = 0
        self.curr = 1
        self.n = n

    def __iter__(self):  # 调用__iter__方法返回迭代器对象，返回自身，自身就是迭代器对象
        return self

    def __next__(self):  # 调用__next__方法返回下一个值
        self.prev, self.curr = self.curr, self.curr + self.prev
        if self.prev > self.n:
            raise StopIteration
        return self.prev


# f = Fib(20)
# for i in f:
#     print(i)
#Fib既是一个可迭代对象（因为它实现了__iter__方法），又是一个迭代器（因为实现了__next__方法），实例变量prev,curr用户维护迭代器内部的状态
#每次调用next()方法的时候做两件事：
#1、为下一次调用next()方法修改状态  2、为当前这次调用生成返回结果
"""
生成器
"""
# 生成器是一种特殊的迭代器，只需要一个yield关键字,生成器一定是迭代器，反之不成立
def fibs():
    prev,curr=0,1
    while curr<10:
        yield curr
        prev,curr=curr,prev+curr
f=fibs()
for i in f:
    print(i)
"""
总结
"""
#1、容器时一系列元素的集合，容器都可以被迭代，因此它们都被称为可迭代对象
#2、可迭代对象实现了__iter__方法，该方法返回一个迭代器对象
#3、迭代器持有一个内部状态的字段，用于记录下次迭代返回值，它实现了__iter__和__next__方法，迭代器不会一次性把所有元素加载到内存，而是需要的时候才生成返回结果
#4、生成器是一种特殊的迭代器，他的返回值不是通过return而是通过yield
